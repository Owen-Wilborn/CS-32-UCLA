//Owen Wilborn
//This files contains the code for linkedlist.h, linkedlist.cpp, and main.cpp to test the linkedlist

//linkedlist.h
// LinkedList Header
#ifndef LINKEDLIST_H
#define LINKEDLIST_H

//Local Libraries
//None
//Standard Libraries
#include <string>

typedef std::string ItemType;		//Declare ItemType variable type
//typedef int ItemType;

struct Node {		//Structure Node to contain each item in the linked list
	ItemType value;
	Node* next;
};

class LinkedList {		//Class LinkedList to create a public interface for using linked list
private:
	Node* head;		//head points to first node in list
	int m_numberItems;		//number of items in the list
public:
	// NAME: LinkedList
	// INPUT: None
	// OUTPUT: None
	// DESCRIPTION: default constructor
	LinkedList();
	// NAME: LinkedList
	// INPUT: Refernce to LinkedList
	// OUTPUT: None
	// DESCRIPTION: copy constructor
	LinkedList(const LinkedList& rhs);
	// NAME: ~LinkedList
	// INPUT: None
	// OUTPUT: None
	// DESCRIPTION: Destroys all the dynamically allocated memory in the list.
	~LinkedList();
	// NAME: operator=
	// INPUT: Refernce to LinkedList
	// OUTPUT: None
	// DESCRIPTION: assignment operator
	const LinkedList& operator=(const LinkedList& rhs);

	//Mutators

	// NAME: insertToFront
	// INPUT: Refernce to item of ItemType
	// OUTPUT: None
	// DESCRIPTION: Inserts val at the front of the list
	void insertToFront(const ItemType& val);
	// NAME: reverseList
	// INPUT: None
	// OUTPUT: None
	// DESCRIPTION: Reverses the LinkedList
	void reverseList();
	// NAME: append
	// INPUT: Refernce to LinkedList
	// OUTPUT: None
	// DESCRIPTION: Appends the values of other onto the end of this LinkedList.
	void append(const LinkedList& other);
	// NAME: swap
	// INPUT: Refernce to LinkedList
	// OUTPUT: None
	// DESCRIPTION: Exchange the contents of this LinkedList with the other one.
	void swap(LinkedList& other);

	//Accessors

	// NAME: get
	// INPUT: Integer for location of item in list, reference to item of ItemType
	// OUTPUT: Bool
	// DESCRIPTION: Sets item to the value at position i in this LinkedList and return true, returns false if there is no element i, list starts numbering at zero
	bool get(int i, ItemType& item) const;
	// NAME: printList
	// INPUT: None
	// OUTPUT: None
	// DESCRIPTION: Prints the LinkedList
	void printList() const;
	// NAME: printReverse
	// INPUT: None
	// OUTPUT: None
	// DESCRIPTION: Prints the LinkedList in reverse order
	void printReverse() const;
	// NAME: size
	// INPUT: None
	// OUTPUT: integer of the size of the list
	// DESCRIPTION: Returns the number of items in the Linked List.
	int size() const;
};
#endif

//linkedlist.cpp
//LinkedList Implementation

//Prototype Library
#include "LinkedList.h"
//Standard Libraries
#include <iostream>
//#include <string>
using namespace std;

// default constructor
LinkedList::LinkedList()
{
	//Create an empty list
	head = nullptr;
	m_numberItems = 0;
}

// copy constructor
LinkedList::LinkedList(const LinkedList& rhs)
{
	//Create an empty list
	head = nullptr;
	m_numberItems = 0;
	//Copy the rhs list to the new list
	ItemType item;
	//Copy from last item to the first because add the items from the front
	for (int i = (rhs.m_numberItems-1); i >=0; i--)
	{
		//Get the item from old list
		rhs.get(i, item);
		//Insert item into new list
		insertToFront(item);
	}
}
// Destroys all the dynamically allocated memory
// in the list.
LinkedList::~LinkedList()
{
	Node* Ptr = head;
	Node* nextPtr = nullptr;
	//While items exist in list
	while (m_numberItems > 0)
	{
		//Find the next nude
		nextPtr = Ptr->next;
		//Delete this node
		delete Ptr;
		//lower item count
		m_numberItems--;
		//go to the next node
		Ptr = nextPtr;
	}
	//Set to empty list status
	head = nullptr;
	m_numberItems = 0;
}
// assignment operator
const LinkedList& LinkedList::operator=(const LinkedList& rhs)
{
	//Check if assigning something to itself
	if (this == &rhs)
	{
		//Return self for self assignment
		return *this;
	}
	//destory the list to be copied over
	this->~LinkedList();
	ItemType item;
	//Add items from old list into new list in reverse
	for (int i = (rhs.m_numberItems-1); i >= 0; i--)
	{
		//get item from old list
		rhs.get(i, item);
		//add item to the new list
		insertToFront(item);
	}
	//Return new list
	return *this;
}
// Inserts val at the front of the list
void LinkedList::insertToFront(const ItemType& val)
{
	//Create new node
	Node* newNode = new Node;
	//Set item the node
	newNode->value = val;
	//Set the old header to second in list
	newNode->next = head;
	//Set head to new node at front
	head = newNode;
	//increase item count
	m_numberItems++;
	return;
}
// Prints the LinkedList
void LinkedList::printList() const
{
	Node* Entry = head;
	//Iterate from first item to last
	for (int i = 0; i < m_numberItems; i++)
	{
		//Write out the item and a space
		cout << Entry->value << " ";
		//Got to the next item
		Entry = Entry->next;
	}
	//Finish the line jump to new one
	cout << endl;
	return;
}
// Sets item to the value at position i in this
// LinkedList and return true, returns false if
// there is no element i
bool LinkedList::get(int i, ItemType& item) const
{
	//Check if number asking for in the list
	if (i<0 || i>(m_numberItems-1))
	{
		//If not valid number return false
		return false;
	}
	Node* Ptr = head;
	//Iterate though the list until find the num node
	for (int k = 0; k<i; k++)
	{
		//Iterate through node pointers
		Ptr = Ptr->next;
	}
	//Get thats node's value
	item = Ptr->value;
	//return true found the node in looking
	return true;
}
// Reverses the LinkedList
void LinkedList::reverseList()
{
	//Create new empty list of reverse
	LinkedList reverse;
	ItemType item;
	bool test;
	//Iterate through list input to collect all nodes
	for (int i=0; i<m_numberItems; i++)
	{
		//If item was in the old list get it
		test = get(i,item);
		if (test == true)
		{
			//Place in the front of the return list
			reverse.insertToFront(item);
		}
	}
	//Copy over the reversed list into the input list
	*this = reverse;
	//Delete the reverse list
	reverse.~LinkedList();
	return;
}
// Prints the LinkedList in reverse order
void LinkedList::printReverse() const
{
	//Create hold list identical to list input
	LinkedList holder;
	holder = *this;
	//Reverse the holder list and print it
	holder.reverseList();
	holder.printList();
	//Destroy the holder list
	holder.~LinkedList();
	return;
}
// Appends the values of other onto the end of this
// LinkedList.
void LinkedList::append(const LinkedList& other)
{
	Node* preNode = head;
	ItemType item;
	//For each node in the list to append to the other list
	for (int i=0; i<other.m_numberItems; i++)
	{
		//Check if list is empty first
		if (preNode == nullptr)
		{
			//Create new node at the end
			Node* newNode = new Node;
			//get and input the correct values into the new node
			other.get(i, item);
			newNode->value = item;
			//Link the new node at the end
			head = newNode;
			newNode->next = nullptr;
			preNode = head;
			//Increse the item count
			m_numberItems++;
			continue;
		}
		//Find end of list want to append to
		while(preNode->next!=nullptr)
		{
			preNode = preNode->next;
		}
		//Create new node at the end
		Node* newNode = new Node;
		//get and input the correct values into the new node
		other.get(i, item);
		newNode->value = item;
		//Link the new node at the end
		preNode->next = newNode;
		newNode->next = nullptr;
		//Increse the item count
		m_numberItems++;
	}
	return;
}
// Exchange the contents of this LinkedList with the other
// one.
void LinkedList::swap(LinkedList& other)
{
	//create new empty list
	LinkedList temp;
	//assign other to temp
	temp = other;
	//overwrite other with the list
	other = *this;
	//overwrite the list with the temp
	*this = temp;
	//destory the temp list
	temp.~LinkedList();
	return;
}
// Returns the number of items in the Linked List.
int LinkedList::size() const
{
	//return the number of items in the list
	return m_numberItems;
}

//main.cpp
//Local Libraries
#include "LinkedList.h"
#include "LinkedList.h"
//Standard Libraries
//#include <string>
#include <iostream>
#include <cassert>
using namespace std;

int main()
{
	/*
	//CS test cases
	cout << "****Provided Test Cases****" <<endl;
	cout << "---Test 1---" << endl;
	LinkedList ls;
	ls.insertToFront("Hawkeye");
	ls.insertToFront("Thor");
	ls.insertToFront("Hulk");
	ls.insertToFront("Black Widow");
	ls.insertToFront("Iron Man");
	ls.insertToFront("Captain America");
	string check[6] = {"Captain America", "Iron Man","Black Widow","Hulk","Thor","Hawkeye"};
	for (int k = 0; k < ls.size(); k++)
	{
		string x;
		ls.get(k, x);
		assert(x == check[k]);
		cout << x << endl;
	}
	ls.~LinkedList();

	cout << endl << "---Test 2---" << endl;


	//LinkedList ls;
	ls.insertToFront("The Mandalorian");
	ls.insertToFront("Baby Yoda");
	ls.insertToFront("Cara Dune");
	ls.insertToFront("Greef Karga");
	string Front;
	string value;
	for (int i = 0; i < (ls.size()); i++)
	{
		ls.get(i, value);
		//Write out the item and a space
		Front = Front + value + " ";
	}
	assert(Front == "Greef Karga Cara Dune Baby Yoda The Mandalorian ");
	string Reverse;
	for (int i = ls.size()-1; i >= 0; i--)
	{
		ls.get(i, value);
		//Write out the item and a space
		Reverse = Reverse + value + " ";
	}
	assert(Reverse == "The Mandalorian Baby Yoda Cara Dune Greef Karga ");
	ls.printList();
	ls.printReverse();
	ls.~LinkedList();

	cout << endl << "---Test 3---" << endl;

	LinkedList e1;
	e1.insertToFront("Athos");
	e1.insertToFront("Porthos");
	e1.insertToFront("Aramis");
	LinkedList e2;
	e2.insertToFront("Robin");
	e2.insertToFront("Batman");
	e1.append(e2); // adds contents of e2 to the end of e1
	string s;
	assert(e1.size() == 5 && e1.get(3, s) && s == "Batman");
	assert(e2.size() == 2 && e2.get(1, s) && s == "Robin");
	e1.~LinkedList();
	e2.~LinkedList();
	cout << "Test 3 Passed" << endl;

	cout << endl << "---Test 4---" << endl;

	//LinkedList e1;
	e1.insertToFront("Jim");
	e1.insertToFront("Oz");
	e1.insertToFront("Paul");
	e1.insertToFront("Kevin");
	e1.reverseList(); // reverses the contents of e1
	assert(e1.size() == 4 && e1.get(0, s) && s == "Jim");
	e1.~LinkedList();
	cout << "Test 4 Passed" << endl;

	cout << endl << "---Test 5---" << endl;

	//LinkedList e1;
	e1.insertToFront("A");
	e1.insertToFront("B");
	e1.insertToFront("C");
	e1.insertToFront("D");
	//LinkedList e2;
	e2.insertToFront("X");
	e2.insertToFront("Y");
	e2.insertToFront("Z");
	e1.swap(e2); // exchange contents of e1 and e2
	//string s;
	assert(e1.size() == 3 && e1.get(0, s) && s == "Z");
	assert(e2.size() == 4 && e2.get(2, s) && s == "B");
	cout << "Test 5 Passed" << endl;
	cout <<"****End Provided Test Cases****" << endl << endl;

	//My test cases
	cout << "****My Test Cases****" << endl;
	LinkedList list1;
	string item = "Hello";
	assert(list1.size() == 0 && list1.get(0, item) == false && item == "Hello" );
	list1.insertToFront("1");
	assert(list1.size() == 1 && list1.get(0, item) == true && item == "1");
	list1.insertToFront("2");
	assert(list1.size() == 2);
	assert(list1.get(0, item) == true && item == "2");
	assert(list1.get(1, item) == true && item == "1");
	assert(list1.get(2, item) == false && item == "1");
	LinkedList list2(list1);
	list1.~LinkedList();
	item = "Hello";
	assert(list1.size() == 0 && list1.get(0, item) == false && item == "Hello");
	assert(list2.size() == 2 && list2.get(0, item) == true && item == "2" && list2.get(1, item) == true && item == "1" && list2.get(2, item) == false && item == "1");
	LinkedList list3(list1);
	item = "Hello";
	assert(list3.size() == 0 && list3.get(0, item) == false && item == "Hello");
	list1 = list2;
	assert(list1.size() == 2 && list1.get(0, item) == true && item == "2" && list1.get(1, item) == true && item == "1" && list1.get(2, item) == false && item == "1");
	list1 = list3;
	item = "Hello";
	assert(list1.size() == 0 && list1.get(0, item) == false && item == "Hello");
	list1.~LinkedList();
	assert(list1.size() == 0 && list1.get(0, item) == false && item == "Hello");
	list1.insertToFront("1");
	list1.insertToFront("2");
	list1.insertToFront("3");
	assert(list1.size() == 3 && list1.get(0, item) == true && item == "3" && list1.get(1, item) == true && item == "2" && list1.get(2, item) == true && item == "1" && list1.get(3, item) == false && item == "1");
	list1.reverseList();
	assert(list1.size() == 3 && list1.get(0, item) == true && item == "1" && list1.get(1, item) == true && item == "2" && list1.get(2, item) == true && item == "3" && list1.get(3, item) == false && item == "3");
	list1.reverseList();
	list1.insertToFront("4");
	assert(list1.size() == 4 && list1.get(0, item) == true && item == "4" && list1.get(1, item) == true && item == "3" && list1.get(2, item) == true && item == "2" && list1.get(3, item) == true && item == "1" && list1.get(4, item) == false && item == "1");
	list1.reverseList();
	assert(list1.size() == 4 && list1.get(0, item) == true && item == "1" && list1.get(1, item) == true && item == "2" && list1.get(2, item) == true && item == "3" && list1.get(3, item) == true && item == "4" && list1.get(4, item) == false && item == "4");
	list2.~LinkedList();
	list1.append(list2);
	assert(list1.size() == 4 && list1.get(0, item) == true && item == "1" && list1.get(1, item) == true && item == "2" && list1.get(2, item) == true && item == "3" && list1.get(3, item) == true && item == "4" && list1.get(4, item) == false && item == "4");
	list2.insertToFront("6");
	list2.insertToFront("5");
	list1.append(list2);
	list2.~LinkedList();
	assert(list1.size() == 6 && list1.get(0, item) == true && item == "1" && list1.get(1, item) == true && item == "2" && list1.get(2, item) == true);
	assert(list1.get(4, item) == true && item == "5");
	assert(list1.get(5, item) == true && item == "6");
	assert(list1.get(6, item) == false && item == "6");
	list1.~LinkedList();
	list2.~LinkedList();
	list1.insertToFront("1");
	list1.insertToFront("2");
	list2.insertToFront("3");
	list2.insertToFront("4");
	list1.swap(list2);
	assert(list1.size() == 2 && list1.get(0, item) == true && item == "4");
	assert(list2.size() == 2 && list2.get(0, item) == true && item == "2");
	list1.~LinkedList();
	list2.swap(list1);
	assert(list1.size() == 2 && list1.get(0, item) == true && item == "2");
	assert(list2.size() == 0 && list2.get(0, item) == false && item == "2");
	list1.~LinkedList();
	list2.~LinkedList();
	list3.~LinkedList();
	list1.insertToFront("2");
	list1.insertToFront("1");
	list1 = list1;
	list1.printList();
	list1.printReverse();
	assert(list1.get(-1, item) == false);
	list1.~LinkedList();
	cout << "****End My Test Cases****" << endl << endl;

	//Other Test
	LinkedList list1;
	list1.insertToFront(1);
	list1.insertToFront(2);
	list1.printList();
}
